return (data.frame(apply_resting_period((start_time + duration),unsanctioned), duration))
}
unsanctioned
apply_resting_period((start_time + duration),unsanctioned)
(start_time + duration)
unsanctioned
data.frame(apply_resting_period(hr, (start_time + duration),unsanctioned), duration)
data.frame(apply_resting_period(hrs, (start_time + duration),unsanctioned), duration)
assign_elf_to_toy <- function(input_time, current_elf, current_toy, hrs){
#     Given a toy, assigns the next elf to the toy. Computes the elf's updated rating,
#     applies the rest period (if any), and sets the next available time.
#     :param input_time: list of tuples (next_available_time, elf)
#     :param current_elf: elf object
#     :param current_toy: toy object
#     :param hrs: hours object
#     :return: list of elves in order of next available
source("hours.R")
start_time <- next_sanctioned_minute(hours_init, input_time)  # double checks that work starts during sanctioned work hours
duration <- as.integer(ceiling(current_toy$duration / current_elf$rating))
sanctioned <- get_sanctioned_breakdown(hrs, start_time, duration)$sanctioned
unsanctioned <- get_sanctioned_breakdown(hrs, start_time, duration)$unsanctioned
if(unsanctioned == 0){
return (data.frame(next_sanctioned_minute((start_time + duration)), duration))
}else{
return (data.frame(apply_resting_period(hrs, (start_time + duration),unsanctioned), duration))
}
}
current_elf$next_available_time <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1]
work_duration <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[2]
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
current_elf
myelves[1,]
current_elf$next_available_time
current_elf
current_elf <- myelves[1,]
current_elf
current_elf$next_available_time
assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1]
current_elf$next_available_time <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1]
current_elf
current_elf <- myelves[1,]
current_elf$next_available_time[1] <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1]
current_elf
work_duration <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[2]
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
hrs
current_toy
work_start_time
work_duration
current_elf
update_next_available_minute(current_elf, hrs, work_start_time, work_duration)
get_sanctioned_breakdown(hrs, work_start_time, work_duration)
start_time
work_start_time
work_duration
duration
work_duration[1]
work_duration
current_elf <- update_elf(current_elf, hrs, current_toy, 541, work_duration)
work_start_time + work_duration
work_start_time + work_duration -1
current_elf
(start_minute + duration - 1)
work_start_time+ duration - 1
get_sanctioned_breakdown(hours_init, start_minute, duration)
get_sanctioned_breakdown(hrs, work_start_time, work_duration)
get_sanctioned_breakdown(hrs, work_start_time, 5)
work_duration
work_duration[1,1]
assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[2,1]
assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[2]
assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1,2]
work_duration <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1,2]
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
remainder_start
get_sanctioned_breakdown <- function(hours_init, start_minute, duration){
#     Whole days (24-hr time periods) contribute fixed quantities of sanctioned and unsanctioned time. After
#     accounting for the whole days in the duration, the remainder minutes are tabulated as un/sanctioned.
#     :param start_minute:
#     :param duration:
#     :return:
full_days <- duration / (hours_init$minutes_in_24h)
sanctioned <- full_days * hours_init$hours_per_day * 60
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
for(minute in remainder_start:(start_minute+duration)){
if (is_sanctioned_time(hours_init, minute)){
sanctioned <- sanctioned + 1
}else{
unsanctioned <- unsanctioned + 1
}
}
return (data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned))
}
work_duration <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1,2]
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
source("hours.R")
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
source('hours.R')
work_start_time
duration
hours_init
start_minute <- work_start_time
duration\
duration
full_days <- duration / (hours_init$minutes_in_24h)
full_days
sanctioned <- full_days * hours_init$hours_per_day * 60
sanctioned
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
unsanctioned
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
remainder_start
(start_minute + duration - 1)
remainder_start
remainder_start:(start_minute + duration - 1)
for(minute in remainder_start:(start_minute + duration - 1)){
if (is_sanctioned_time(hours_init, minute)){
sanctioned <- sanctioned + 1
}else{
unsanctioned <- unsanctioned + 1
}
}
return (data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned))
data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned)
######################
### Init Parameter ###
######################
hours_per_day <- 10 # 10 hour day: 9 - 19
day_start <- 9 * 60
day_end <- (9 + hours_per_day) * 60
minutes_in_24h <- 24 * 60
hours_init <- data.frame(
hours_per_day = hours_per_day, # 10 hour day: 9 - 19
day_start = day_start,
day_end = day_end,
minutes_in_24h = minutes_in_24h
)
####################################
### 目前时间和开始时间相差分钟数 ###
####################################
convert_to_minute <- function(arrival){
#     Converts the arrival time string to minutes since the reference start time,
#     Jan 1, 2014 at 00:00 (aka, midnight Dec 31, 2013)
#     :param arrival: string in format '2014 12 17 7 03' for Dec 17, 2014 at 7:03 am
#     :return: integer (minutes since arrival time)
time <- strsplit(x = arrival, split = ' ')
time1 <- paste(paste(time[[1]][1],time[[1]][2],time[[1]][3],sep = '/'),paste(time[[1]][4],time[[1]][5],sep = ":"),sep = " ")
time1 <- strftime(time1, "%Y-%m-%d %H:%M:%OS")
time2 <- strftime("2014/1/1 0:0", "%Y-%m-%d %H:%M:%OS")
age <- as.integer(difftime(time1, time2, units = "mins"))
return(age)
}
# convert_to_minute(input$Arrival_time)
######################
### 是否在工作时间 ###
######################
is_sanctioned_time <- function(hours_init, minute){
#     Return boolean True or False if a given time (in minutes) is a sanctioned working day minute.
return (((minute - hours_init$day_start) %% hours_init$minutes_in_24h) < (hours_init$hours_per_day * 60))
}
# is_sanctioned_time(hours_init, 19*60-1)
##############################
### 分配每分钟是否工作时间 ###
##############################
get_sanctioned_breakdown <- function(hours_init, start_minute, duration){
#     Whole days (24-hr time periods) contribute fixed quantities of sanctioned and unsanctioned time. After
#     accounting for the whole days in the duration, the remainder minutes are tabulated as un/sanctioned.
#     :param start_minute:
#     :param duration:
#     :return:
full_days <- duration / (hours_init$minutes_in_24h)
sanctioned <- full_days * hours_init$hours_per_day * 60
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
for(minute in remainder_start:(start_minute + duration - 1)){
if (is_sanctioned_time(hours_init, minute)){
sanctioned <- sanctioned + 1
}else{
unsanctioned <- unsanctioned + 1
}
}
return (data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned))
}
# get_sanctioned_breakdown(hours_init, 12*60, 1000)
####################################
### 给一分钟，计算下一个工作分钟 ###
####################################
next_sanctioned_minute <- function(hours_init, minute){
#     Given a minute, finds the next sanctioned minute.
#     :param minute: integer representing a minute since reference time
#     :return: next sanctioned minute
if(is_sanctioned_time(hours_init, minute) & is_sanctioned_time(hours_init, (minute+1))){
return(minute + 1)
}
num_days <- minute / hours_init$minutes_in_24h
return(hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h)
}
# next_sanctioned_minute(hours_init, hours_init$day_start+12)
################################
### 剩余时间和下次可工作时间 ###
################################
apply_resting_period <- function(hours_init, start, num_unsanctioned){
#     Enforces the rest period and returns the minute when the elf is next available for work.
#     Rest period is only applied to sanctioned work hours.
#     :param start: minute the REST period starts
#     :param num_unsanctioned: always > 0 number of unsanctioned minutes that need resting minutes
#     :return: next available minute after rest period has been applied
num_days_since_jan1 <- start / hours_init$minutes_in_24h
rest_time <- num_unsanctioned
rest_time_in_working_days <- rest_time / (60 * hours_init$hours_per_day)
rest_time_remaining_minutes <- rest_time %% (60 * hours_init$hours_per_day)
#     rest time is only applied to sanctioned work hours. If local_start is at an unsanctioned time,
#     need to set it to be the next start of day
local_start <- start %% hours_init$minutes_in_24h  # minute of the day (relative to a current day) the work starts
if(local_start < hours_init$day_start){
local_start <- hours_init$day_start
}else if(local_start > hours_init$day_end){
num_days_since_jan1 <- num_days_since_jan1 + 1
}
local_start <- hours_init$day_start
if((local_start + rest_time_remaining_minutes) > hours_init$day_end){
rest_time_in_working_days <- rest_time_in_working_days + 1
}
rest_time_remaining_minutes <- rest_time_remaining_minutes - (hours_init$day_end - local_start)
local_start <- hours_init$day_start
total_days <- num_days_since_jan1 + rest_time_in_working_days
return (total_days * hours_init$minutes_in_24h + local_start + rest_time_remaining_minutes)
}
# apply_resting_period(hours_init, 12*60, 585.3333)
source('hours.R')
######################
### Init Parameter ###
######################
elf_init <- function(input){
#     Each Elf starts with a rating of 1.0 and are available at 09:00 on Jan 1.
id <- input$elfid
rating <- 1.0
next_available_time <- 540  # Santa's Workshop opens Jan 1, 2014 9:00 (= 540 minutes)
rating_increase <- 1.02
rating_decrease <- 0.90
return(data.frame(id=id, rating=rating, next_available_time=next_available_time,
rating_increase=rating_increase, rating_decrease=rating_decrease))
}
# elf_list <- elf_init(elf)
##############################
### 更新效率和下次工作时间 ###
##############################
update_elf <- function(elf_list, hrs, toy, start_minute, duration){
#     Updates the elf's productivity rating and next available time based on last toy completed.
#     :param hrs: Hours object for bookkeeping
#     :param toy: Toy object for the toy the elf just finished
#     :param start_minute: minute work started
#     :param duration: duration of work, in minutes
#     :return: void
elf_list <- update_next_available_minute(elf_list, hrs, start_minute, duration)
elf_list <- update_productivity(elf_list, hrs, start_minute, as.integer(ceiling(toy$Duration / elf_list$rating)))
return(elf_list)
}
# update_elf(elf_list[1,], hours_init, input, 1221, 223)
##########################
### 更新下次可工作时间 ###
##########################
update_next_available_minute <- function(elf_list, hours_init, start_minute, duration){
#     Apply the resting time constraint and determine the next minute when the elf can work next.
#     Here, elf can only start work during sanctioned times
#     :param start_minute: time work started on last toy
#     :param duration: duration of work on last toy
#     :return: void
sanctioned <- get_sanctioned_breakdown(hours_init, start_minute, duration)$sanctioned
unsanctioned <- get_sanctioned_breakdown(hours_init, start_minute, duration)$unsanctioned
# enforce resting time based on the end_minute and the unsanctioned minutes that
# need to be accounted for.
end_minute <- start_minute + duration
if (unsanctioned == 0 ){
if (is_sanctioned_time(hrs, end_minute)){
elf_list$next_available_time <- end_minute
}else{
elf_list$next_available_time <- next_sanctioned_minute(hours_init, end_minute)
}
}else{
elf_list$next_available_time <- apply_resting_period(hours_init, end_minute, unsanctioned)
}
return (elf_list)
}
# elf_list <- update_next_available_minute(elf_list[1,], hours_init, 1221, 223)
####################
### 更新工作效率 ###
####################
update_productivity <- function(elf_list, hours_init, start_minute, toy_required_minutes){
#     Update the elf's productivity rating based on the number of minutes the toy required that were
#     worked during sanctioned and unsanctioned times.
#     max(0.5,
#     min(2.0, previous_rating * (self.rating_increase ** sanctioned_hours) *
#     (self.rating_decrease ** unsanctioned_hours)))
#     :param hrs: hours object
#     :param start_minute: minute work started
#     :param toy_required_minutes: minutes required to build the toy (may be different from minutes elf worked)
#     :return: void
# number of required minutes to build toy worked by elf, broken up by sanctioned and unsanctioned minutes
sanctioned <- get_sanctioned_breakdown(hours_init, start_minute, toy_required_minutes)$sanctioned
unsanctioned <- get_sanctioned_breakdown(hours_init, start_minute, toy_required_minutes)$unsanctioned
elf_list$rating <- max(0.25,min(4.0, elf_list$rating * (elf_list$rating_increase ** (sanctioned/60)) *
(elf_list$rating_decrease ** (unsanctioned/60))
))
return(elf_list)
}
# elf_list <- update_productivity(elf_list, hours_init, 1000, 100)
######################
### Init Parameter ###
######################
toy_init <- function(input){
reference_start_time <- strftime("2015/1/1 0:0", "%Y-%m-%d %H:%M:%OS")  # set when elf starts working on toy
id = input$ToyId
arrival_minute <- convert_to_minute(as.character(input$Arrival_time))
duration <- as.integer(input$Duration)
completed_minute <- 0
return(data.frame(reference_start_time=reference_start_time, id=id,
arrival_minute=arrival_minute, duration=duration, completed_minute=completed_minute))
}
# input <- toys_rev2[888,]
# toy_task <- toy_init(input)
##################################
### 开始时间是否在到达时间之后 ###
##################################
outside_toy_start_period <- function(arrival_minute, start_minute){
# Checks that work on toy does not start outside of the allowed starting period.
# :param hrs: Hours class
# :param start_minute: minute the work is scheduled to start
# :return: True of outside of allowed starting period, False otherwise
return (start_minute < arrival_minute)
}
# outside_toy_start_period(toy_task$arrival_minute, 10000)
##################################
### 是否完成根据工作时间和效率 ###
##################################
is_complete <- function(duration, completed_minute, start_minute, elf_duration, rating){
# Determines if the toy is completed given duration of work and elf's productivity rating
# param start_minute: minute work started
# param elf_duration: duration of work in minutes
# param rating: elf's productivity rating
# return: Boolean
if (duration/rating <= elf_duration){
completed_minute <- start_minute + as.integer(ceiling(duration/rating))
return(completed_minute)
}else{
return(FALSE)
}
}
# is_complete(toy_task$duration, toy_task$completed_minute, 100000, 10, 1.2)
current_elf$next_available_time[1] <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1]
work_duration <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1,2]
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
elf_list <- update_next_available_minute(elf_list, hrs, start_minute, duration)
get_sanctioned_breakdown(hours_init, start_minute, duration)
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
hours_init
hrs
start_minute
work_start_time
duration
work_duration
unsanctioned <- get_sanctioned_breakdown(hours_init, start_minute, duration)$unsanctioned
end_minute <- start_minute + duration
if (unsanctioned == 0 ){
if (is_sanctioned_time(hrs, end_minute)){
elf_list$next_available_time <- end_minute
}else{
elf_list$next_available_time <- next_sanctioned_minute(hours_init, end_minute)
}
}else{
elf_list$next_available_time <- apply_resting_period(hours_init, end_minute, unsanctioned)
}
elf_list <- current_elf
if (unsanctioned == 0 ){
if (is_sanctioned_time(hrs, end_minute)){
elf_list$next_available_time <- end_minute
}else{
elf_list$next_available_time <- next_sanctioned_minute(hours_init, end_minute)
}
}else{
elf_list$next_available_time <- apply_resting_period(hours_init, end_minute, unsanctioned)
}
elf_list
current_elf
elf_list <- update_next_available_minute(elf_list, hrs, start_minute, duration)
elf_list <- update_productivity(elf_list, hrs, start_minute, as.integer(ceiling(toy$Duration / elf_list$rating)))
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
current_toy
toy <- current_toy
elf_list <- update_productivity(elf_list, hrs, start_minute, as.integer(ceiling(toy$Duration / elf_list$rating)))
sanctioned <- get_sanctioned_breakdown(hours_init, start_minute, toy_required_minutes)$sanctioned
as.integer(ceiling(toy$Duration / elf_list$rating))
toy$Duration
update_elf <- function(elf_list, hrs, toy, start_minute, duration){
#     Updates the elf's productivity rating and next available time based on last toy completed.
#     :param hrs: Hours object for bookkeeping
#     :param toy: Toy object for the toy the elf just finished
#     :param start_minute: minute work started
#     :param duration: duration of work, in minutes
#     :return: void
elf_list <- update_next_available_minute(elf_list, hrs, start_minute, duration)
elf_list <- update_productivity(elf_list, hrs, start_minute, as.integer(ceiling(toy$duration / elf_list$rating)))
return(elf_list)
}
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
current_elf
myelves[1,] <- current_elf
myelves <- myelves[order(myelves$next_available_time),]
tt <- ref_time + 60*work_start_time
time_string <- strftime(tt, '%Y %m %d %H %M')
wcsv <- rbind(wcsv, c(current_toy$id, current_elf$id, time_string, work_duration))
colnames(wcsv) <- c('ToyId', 'ElfId', 'StartTime', 'Duration')
wcsv
setwd('/Users/ivan/Work_directory/FICO/Helping-Santas-Helpers/')
gc(); rm(list=ls())
source("hours.R"); source("elf.R"); source("toy.R")
elf <- data.frame(elfid = 1:900)
setwd('/Users/ivan/Work_directory/FICO/Helping-Santas-Helpers/')
gc(); rm(list=ls())
source("hours.R"); source("elf.R"); source("toy.R")
elf <- data.frame(elfid = 1:900)
start <- Sys.time()
NUM_ELVES <- 900
load('data/toys_rev2.RData')
load('data/sampleSubmission_rev1.RData')
myelves <- create_elves(NUM_ELVES)
####################
### create_elves ###
####################
create_elves <- function(NUM_ELVES){
#     Elves are stored in a sorted list using heapq to maintain their order by next available time.
#     List elements are a tuple of (next_available_time, elf object)
#     :return: list of elves
source("elf.R")
elf <- data.frame(elfid = 1:900)
list_elves <- elf_init(elf)
return(list_elves)
}
#########################
### assign_elf_to_toy ###
#########################
assign_elf_to_toy <- function(input_time, current_elf, current_toy, hrs){
#     Given a toy, assigns the next elf to the toy. Computes the elf's updated rating,
#     applies the rest period (if any), and sets the next available time.
#     :param input_time: list of tuples (next_available_time, elf)
#     :param current_elf: elf object
#     :param current_toy: toy object
#     :param hrs: hours object
#     :return: list of elves in order of next available
source("hours.R")
start_time <- next_sanctioned_minute(hours_init, input_time)  # double checks that work starts during sanctioned work hours
duration <- as.integer(ceiling(current_toy$duration / current_elf$rating))
sanctioned <- get_sanctioned_breakdown(hrs, start_time, duration)$sanctioned
unsanctioned <- get_sanctioned_breakdown(hrs, start_time, duration)$unsanctioned
if(unsanctioned == 0){
return (data.frame(next_sanctioned_minute((start_time + duration)), duration))
}else{
return (data.frame(apply_resting_period(hrs, (start_time + duration),unsanctioned), duration))
}
}
##################################
### solution_firstAvailableElf ###
##################################
solution_firstAvailableElf <- function(toy_file, soln_file, myelves){
#     Creates a simple solution where the next available elf is assigned a toy. Elves do not start
#     work outside of sanctioned hours.
#     :param toy_file: filename for toys file (input)
#     :param soln_file: filename for solution file (output)
#     :param myelves: list of elves in a priority queue ordered by next available time
#     :return:
source("hours.R")
hrs <- hours_init
ref_time <- strptime(c("1.1.2014 0:0"), format = "%d.%m.%Y %H:%M")
myToys <- toy_init(toy_file)
wcsv <- data.frame()
for(i in 1:nrow(myToys)){
current_toy <- myToys[i,]
# get next available elf
elf_available_time <- myelves$next_available_time[1]
current_elf <- myelves[1,]
work_start_time <- elf_available_time
if (current_toy$arrival_minute > elf_available_time){
work_start_time <- current_toy$arrival_minute
}
# work_start_time cannot be before toy's arrival
if (work_start_time < current_toy$arrival_minute){
stop(paste('Work_start_time:', work_start_time, 'before arrival minute:',current_toy$arrival_minute))
}
current_elf$next_available_time[1] <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1]
work_duration <- assign_elf_to_toy(work_start_time, current_elf, current_toy, hrs)[1,2]
current_elf <- update_elf(current_elf, hrs, current_toy, work_start_time, work_duration)
# put elf back in heap
myelves[1,] <- current_elf
myelves <- myelves[order(myelves$next_available_time),]
# write to file in correct format
tt <- ref_time + 60*work_start_time
time_string <- strftime(tt, '%Y %m %d %H %M')
wcsv <- rbind(wcsv, c(current_toy$id, current_elf$id, time_string, work_duration))
}
colnames(wcsv) <- c('ToyId', 'ElfId', 'StartTime', 'Duration')
return(wcsv)
}
myelves <- create_elves(NUM_ELVES)
submissions <- solution_firstAvailableElf(toys_rev2, sample, myelves)
warnings()
submissions
head(toys_rev2)
submissions <- solution_firstAvailableElf(toys_rev2[1:1000,], sample, myelves)
submissions
