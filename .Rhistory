delta <- fx1-fcurrent # difference
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else if{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste(' -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
}
}
N0
### main loop ###
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('Chain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste(' - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in ifelse((Ns-Np)<0,1,(Ns-Np)):(Ns+Np)){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else if{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste(' -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
}
}
Ns <- xbest[N0[c]]
Ns
1:S
Np <- (1+h+s/10)
Np
max((Ns-Np),1):min((Ns+Np),nrow(myToys))
np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))
xcurrent[Ns]
x1[Ns]
x1[np]
np
x1
xcurrent[np]
x1[np]
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('Chain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste(' - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else if{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste(' -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
}
}
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('Chain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste(' - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste(' -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
}
}
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('\nChain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste('\n - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
cat(paste('\n -- Delta:',delta))
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste('\n -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
cat(paste('\n -- Temperature:',temperature))
}
}
xcurrent
x1 <- xcurrent
np
Ns
x1[np]
xcurrent[Ns]
Ns <- xbest[N0[c]]
Ns
max((Ns-Np),1):min((Ns+Np),nrow(myToys))
np <- 7776.8
x1 <- xcurrent
x1[np]
xcurrent[Ns]
x1[Ns]
xcurrent[np]
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
x1[np]
x1[Ns]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
fx1
fcurrent
fx0 <- solution_Elf(myToys, myelves, x0)
fx0
x1
myToys[np,]
a <- myToys[schedule,]
a[np,]
a <- myToys[order(schedule),]
a[np,]
a <- myToys[sort(schedule),]
a[np,]
schedule
head(myToys)
schedule[1,]
schedule[1]
schedule[10000]
schedule[10000] <- 1
schedule[1] <- 10000
a <- myToys[schedule,]
head(a)
a[10000,]
solution_Elf <- function(myToys, myelves, schedule){
# cat(format(Sys.time(),format = '%Y-%m-%d %H:%M:%S'))
outcomes <- matrix(0, nrow = nrow(myToys), ncol = 5,
dimnames = list(NULL, c('ToyId', 'ElfId', 'StartTime', 'Duration', 'current_rating')))
myToys <- myToys[schedule,]
for(current_toy in 1:nrow(myToys)){
c_toy_id <- myToys[current_toy,'ToyId']
c_toy_arrival <- myToys[current_toy, 'Arrival_time']
c_toy_duration <- myToys[current_toy,'Duration']
c_elf_id <- myelves[, 'elf_id']
c_elf_start_time <- myelves[, 'next_available_time']
c_elf_rating <- myelves[, 'current_rating']
if(c_elf_start_time < c_toy_arrival) c_elf_start_time <- c_toy_arrival
work_duration <- as.integer(ceiling(c_toy_duration/c_elf_rating))
myelves[, 'next_available_time'] <- update_next_available_minute(c_elf_start_time, work_duration)
myelves[, 'current_rating'] <- update_productivity(c_elf_start_time, work_duration, c_elf_rating)
outcomes[current_toy,] <- c(c_toy_id, c_elf_id, c_elf_start_time, work_duration, c_elf_rating)
#         if(current_toy %% 10000 == 0) cat('\nCompleted', current_toy/1000000, 'mil toys, makespan', c_elf_start_time, 'minutes',
#                                            format(Sys.time(),format = '%Y-%m-%d %H:%M:%S'))
}
# cat('\nCompleted 10 mil toys at', convert_to_chardate(c_elf_start_time))
return(outcomes[nrow(outcomes), 3]+outcomes[nrow(outcomes), 4])
}
setwd('/Users/ivan/Work_directory/FICO/Helping-Santas-Helpers/')
gc(); rm(list=ls())
source('R code/Functions.R')
load('data/toys.RData')
require(caret)
toys_dat <- data.frame(toys)
index <- createDataPartition(toys_dat$Duration, p = 1/900, list = F)
myToys <- data.matrix(toys_dat[index,])
schedule <- c(1:nrow(myToys))
NUM_ELVES <- 1
myelves <- create_elves(NUM_ELVES)
solution_Elf <- function(myToys, myelves, schedule){
# cat(format(Sys.time(),format = '%Y-%m-%d %H:%M:%S'))
outcomes <- matrix(0, nrow = nrow(myToys), ncol = 5,
dimnames = list(NULL, c('ToyId', 'ElfId', 'StartTime', 'Duration', 'current_rating')))
myToys <- myToys[schedule,]
for(current_toy in 1:nrow(myToys)){
c_toy_id <- myToys[current_toy,'ToyId']
c_toy_arrival <- myToys[current_toy, 'Arrival_time']
c_toy_duration <- myToys[current_toy,'Duration']
c_elf_id <- myelves[, 'elf_id']
c_elf_start_time <- myelves[, 'next_available_time']
c_elf_rating <- myelves[, 'current_rating']
if(c_elf_start_time < c_toy_arrival) c_elf_start_time <- c_toy_arrival
work_duration <- as.integer(ceiling(c_toy_duration/c_elf_rating))
myelves[, 'next_available_time'] <- update_next_available_minute(c_elf_start_time, work_duration)
myelves[, 'current_rating'] <- update_productivity(c_elf_start_time, work_duration, c_elf_rating)
outcomes[current_toy,] <- c(c_toy_id, c_elf_id, c_elf_start_time, work_duration, c_elf_rating)
#         if(current_toy %% 10000 == 0) cat('\nCompleted', current_toy/1000000, 'mil toys, makespan', c_elf_start_time, 'minutes',
#                                            format(Sys.time(),format = '%Y-%m-%d %H:%M:%S'))
}
# cat('\nCompleted 10 mil toys at', convert_to_chardate(c_elf_start_time))
return(outcomes[nrow(outcomes), 3]+outcomes[nrow(outcomes), 4])
}
C <- 50 # multiple cooling chain
N0 <- runif(C)*nrow(myToys) # initial point
h <- 5 # used to modulate the step length.
alpha <- .2 # limited to a proportion of ~20% of fx0 in the first step
S <- 5 # current value times, step width
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
xcurrent <- x0; fcurrent <- fx0
T0max <- 0.8*fx0 # initial temperature value
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('\nChain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste('\n - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
cat(paste('\n -- Delta:',delta))
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste('\n -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
cat(paste('\n -- Temperature:',temperature))
}
}
fbest
fbest * 900
fbest
fx0
fx0-fbest
fx0-fbest
fbest
convert_to_chardate(277420389)
fx0
convert_to_chardate(277430398)
C <- 50 # multiple cooling chain
N0 <- runif(C)*nrow(myToys) # initial point
h <- 10 # used to modulate the step length.
alpha <- .2 # limited to a proportion of ~20% of fx0 in the first step
S <- 5 # current value times, step width
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
xcurrent <- x0; fcurrent <- fx0
T0max <- 0.8*fx0 # initial temperature value
### main loop ###
cat(paste('Initial Score:',fbest))
for (c in 1:C){ # multiple cooling chain
Ns <- xbest[N0[c]]
cat(paste('\nChain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste('\n - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta=fx1-fcurrent # difference
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste('\n -- Point:',np,'; Score:',fbest))
}
}
}
}
### parameters ###
C <- 50 # multiple cooling chain
N0 <- runif(C)*nrow(myToys) # initial point
h <- 10 # used to modulate the step length.
alpha <- .2 # limited to a proportion of ~20% of fx0 in the first step
S <- 5 # current value times, step width
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
xcurrent <- x0; fcurrent <- fx0
T0max <- 0.8*fx0 # initial temperature value
### main loop ###
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('\nChain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste('\n - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
cat(paste('\n -- Delta:',delta))
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste('\n -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
cat(paste('\n -- Temperature:',temperature))
}
}
head(myToys)
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),]
head(myToys)
schedule <- c(1:nrow(myToys))
NUM_ELVES <- 1
myelves <- create_elves(NUM_ELVES)
solution_Elf <- function(myToys, myelves, schedule){
# cat(format(Sys.time(),format = '%Y-%m-%d %H:%M:%S'))
outcomes <- matrix(0, nrow = nrow(myToys), ncol = 5,
dimnames = list(NULL, c('ToyId', 'ElfId', 'StartTime', 'Duration', 'current_rating')))
myToys <- myToys[schedule,]
for(current_toy in 1:nrow(myToys)){
c_toy_id <- myToys[current_toy,'ToyId']
c_toy_arrival <- myToys[current_toy, 'Arrival_time']
c_toy_duration <- myToys[current_toy,'Duration']
c_elf_id <- myelves[, 'elf_id']
c_elf_start_time <- myelves[, 'next_available_time']
c_elf_rating <- myelves[, 'current_rating']
if(c_elf_start_time < c_toy_arrival) c_elf_start_time <- c_toy_arrival
work_duration <- as.integer(ceiling(c_toy_duration/c_elf_rating))
myelves[, 'next_available_time'] <- update_next_available_minute(c_elf_start_time, work_duration)
myelves[, 'current_rating'] <- update_productivity(c_elf_start_time, work_duration, c_elf_rating)
outcomes[current_toy,] <- c(c_toy_id, c_elf_id, c_elf_start_time, work_duration, c_elf_rating)
#         if(current_toy %% 10000 == 0) cat('\nCompleted', current_toy/1000000, 'mil toys, makespan', c_elf_start_time, 'minutes',
#                                            format(Sys.time(),format = '%Y-%m-%d %H:%M:%S'))
}
# cat('\nCompleted 10 mil toys at', convert_to_chardate(c_elf_start_time))
return(outcomes[nrow(outcomes), 3]+outcomes[nrow(outcomes), 4])
}
C <- 50 # multiple cooling chain
N0 <- runif(C)*nrow(myToys) # initial point
h <- 10 # used to modulate the step length.
alpha <- .2 # limited to a proportion of ~20% of fx0 in the first step
S <- 5 # current value times, step width
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
xcurrent <- x0; fcurrent <- fx0
T0max <- 0.8*fx0 # initial temperature value
fx0
convert_to_chardate(StartTime)
convert_to_chardate(fx0)
C <- 50 # multiple cooling chain
N0 <- runif(C)*nrow(myToys) # initial point
h <- 10 # used to modulate the step length.
alpha <- .2 # limited to a proportion of ~20% of fx0 in the first step
S <- 5 # current value times, step width
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
xcurrent <- x0; fcurrent <- fx0
T0max <- 0.9*fx0 # initial temperature value
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('\nChain:',c, '; Initial point:', Ns))
for (s in 1:S){
cat(paste('\n - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
cat(paste('\n -- Delta:',delta))
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
}else{
proba <- runif(1)
test <- exp(-delta/temperature)
if(proba<test){
xcurrent <- x1; fcurrent <- fx1
}
}
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste('\n -- Point:',np,'; Score:',fbest))
}
}
temperature <- alpha * temperature
cat(paste('\n -- Temperature:',temperature))
}
}
fbest
fx0
fx0-fbest
fx0-fbest
convert_to_chardate(504567)
fbest
C <- 50 # multiple cooling chain
N0 <- runif(C)*nrow(myToys) # initial point
h <- 10 # used to modulate the step length.
alpha <- .2 # limited to a proportion of ~20% of fx0 in the first step
S <- 5 # current value times, step width
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
xcurrent <- x0; fcurrent <- fx0
T0max <- 1*fx0 # initial temperature value
for (c in 1:C){ # multiple cooling chain
temperature <- T0max
Ns <- xbest[N0[c]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', fbest))
for (s in 1:S){
cat(paste('\n - Step:',s))
Np <- (1+h+s/10) # different initial solution
for (np in max((Ns-Np),1):min((Ns+Np),nrow(myToys))){ # Np = initail point range
x1 <- xcurrent
x1[np] <- xcurrent[Ns] # initial point <> range point
x1[Ns] <- xcurrent[np]
fx1 <- solution_Elf(myToys, myelves, x1) # x1, fx1 - updated schedule and time
delta <- fx1-fcurrent # difference
if(delta<0){
xcurrent <- x1; fcurrent <- fx1 # select better one between fx1, fcurrent and save it into fx1
cat(paste('\n -- Find Improvement:',delta, '!!!'))
}
#             else{
#                 proba <- runif(1)
#                 test <- exp(-delta/temperature)
#                 if(proba<test){
#                     xcurrent <- x1; fcurrent <- fx1
#                 }
#             }
if (fcurrent<fbest){
xbest <- xcurrent; fbest <- fcurrent
cat(paste('\n -- Find Global Improvement!!! Current Score:',fbest))
}
}
temperature <- alpha * temperature
cat(paste('\n -- Temperature:',temperature))
}
}
