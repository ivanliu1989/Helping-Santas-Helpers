}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
index_range <- 1:50 # 5pm-8am | 1.6 min | 35/Hour
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
Ns <- xbest[N0[c]]
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
f_all
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
range(f_all)
index_range <- 1:50 # 5pm-8am | 1.6 min | 35/Hour
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(1000,3000,6000,8000,9000,11000) #c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
Ns <- xbest[N0[c]]
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
index_range <- 1:50 # 5pm-8am | 1.6 min | 35/Hour
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(300,1000,3000,6000,9000,11000) #c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
Ns <- xbest[N0[c]]
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
index_range <- 1:50 # 5pm-8am | 1.8 min | 33/Hour | 215
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(300,1000,3000,6000,9000,11000) #c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
N0[1] <- 6588
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
Ns <- xbest[N0[c]]
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
index_range <- 1:50 # 5pm-8am | 1.8 min | 33/Hour | 215
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(300,1000,3000,6000,9000,11000) #c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
Ns <- 6588 #xbest[N0[c]]
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
range(f_all)
gc()
index_range <- 1:230 # 5pm-8am | 1.8 min | 33/Hour | 215
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(300,1000,3000,6000,9000,11000) #c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
if(c==1){
Ns <- 6588
}else{
Ns <- xbest[N0[c]]
}
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
index_range <- 1:500 # 5pm-8am | 1.8 min | 33/Hour | 215
toys_dat <- data.frame(toys)
C <- 15 # multiple cooling chain
h <- 0 # used to modulate the step length.
S <- c(300,1000,3000,6000,9000,11000) #c(1,3,9,30,90,300,1000,3000,9000) # current value times, step width
NUM_ELVES <- 1
for (index_num in index_range){
n <- match(max(f_all[101:300]),f_all)
set.seed(n)
now <- Sys.time()
cat(paste('\n\nRound :',index_num))
cat(paste('\n Elf:',n))
### Toys establishment ###
myToys <- data.matrix(toys_dat[index[[n]],])
myToys <- myToys[order(myToys[,2]+myToys[,3], myToys[,2]),] # ??
schedule <- x_all[[n]]
myelves <- create_elves(NUM_ELVES)
### parameters ###
N0 <- runif(C)*nrow(myToys) # initial point
x0 <- schedule; fx0 <- solution_Elf(myToys, myelves, x0)
xbest <- x0; fbest <- fx0
for (c in 1:C){
toy_row <- nrow(myToys)
if(c==1){
Ns <- 6588
}else{
Ns <- xbest[N0[c]]
}
Nd <- xbest[N0[min(c+1, C)]]
cat(paste('\nChain:',c, '; Initial point:', Ns, '; Current best score:', round(fbest)))
bk <-0
for (s in S){
cat(paste('\n - Step:',s, 'bk:', bk))
Np <- (1+h+s/10)
num <- length(max((Ns-Np),1):min((Ns+Np),toy_row))
for (np in 1:num){
p <- runif(1)
if(p<=0.5){
partition_1 <- max(((np-1)/num)*toy_row + 1, 1)
partition_2 <- min((np/num)*toy_row, toy_row)
x1 <- xbest
x1[partition_1:partition_2] <- sample(x1[partition_1:partition_2])
}else{
partition_1 <- max((Ns-Np),1):min((Ns+Np),toy_row) ## New
partition_2 <- max((Nd-Np),1):min((Nd+Np),toy_row)
x1 <- xbest
ori_partition <- sample(x1[partition_1]) ## New
des_partition <- sample(x1[partition_2])
x1[partition_1] <- des_partition
x1[partition_2] <- ori_partition
}
fx1 <- solution_Elf(myToys, myelves, x1)
delta <- fx1-fbest
if(delta<0){
xbest <- x1; fbest <- fx1
cat(paste('\n -- Find Improvement:',round(delta), '!!!'))
cat(paste('\n -- Find Global Improvement!!! Current Score:',round(fbest), 'bk:', bk))
bk <- 0
}else{
bk <- bk + 1
}
if (bk > 10) break
}
}
}
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
#     outcome_all[[index_num]] <- solution_Elf_outcome(myToys, myelves, xbest)
cat(paste('\n Time used:',round(Sys.time() - now, digits = 2), '!!!\n'))
}
table(xbest)
toy_row
fbest
x_all[[n]] <- xbest # Record
f_all[n] <- fbest
save(x_all,f_all, file='optimization_results/simulated_annealing_101:300.RData')
gc(); rm(list=ls())
source('R code/Functions.R'); source('R code/c_Functions.r')
setwd('C:/Users/Ivan.Liuyanfeng/Desktop/Data_Mining_Work_Space/FICO/Helping-Santas-Helpers')
gc(); rm(list=ls())
source('R code/Functions.R'); source('R code/c_Functions.r')
