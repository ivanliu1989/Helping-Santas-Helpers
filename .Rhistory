setwd('/Users/ivan/Work_directory/FICO/')
gc(); rm(list=ls())
toy <- read.csv('data/toys_rev1.csv')
save(toy, file = 'data/toys_rev1.RData')
sample <- read.csv('data/sampleSubmission_rev1.csv')
save(sample, file = 'data/sampleSubmission_rev1.RData')
setwd('/Users/ivan/Work_directory/FICO/Helping-Santas-Helpers/')
gc(); rm(list=ls())
load('data/toys_rev1.RData')
reference_start_time = strftime("2014/1/1 0:0", "%Y-%m-%d %H:%M:%OS")  # set when elf starts working on toy
reference_start_time
head(toy)
id = toy$ToyId
id
head(toy)
source(hours.R)
setwd('/Users/ivan/Work_directory/FICO/Helping-Santas-Helpers/')
source(hours.R)
source("hours.R")
source("hours.R")
convert_to_minute <- function(arrival){
#     Converts the arrival time string to minutes since the reference start time,
#     Jan 1, 2014 at 00:00 (aka, midnight Dec 31, 2013)
#     :param arrival: string in format '2014 12 17 7 03' for Dec 17, 2014 at 7:03 am
#     :return: integer (minutes since arrival time)
time = strsplit(x = arrival, split = ' ')
time1 = paste(paste(time[[1]][1],time[[1]][2],time[[1]][3],sep = '/'),paste(time[[1]][4],time[[1]][5],sep = ":"),sep = " ")
time1 = strftime(time1, "%Y-%m-%d %H:%M:%OS")
time2 = strftime("2014/1/1 0:0", "%Y-%m-%d %H:%M:%OS")
age = as.integer(difftime(time1, time2, units = "mins"))
return(age)
}
arrival_minute <- convert_to_minute(toy$Arrival_time)
arrival_minute <- convert_to_minute(as.character(toy$Arrival_time))
duration <- as.integer(toy$Duration)
head(arrival_minute)
arrival_minute
as.character(toy$Arrival_time)
arrival_minute <- sapply(toy$Arrival_time, function(x) convert_to_minute(as.character(x))
)
arrival_minute
arrival_minute[2]
toy[1,]
id = input$ToyId
input <- toy[1,]
id = input$ToyId
arrival_minute <- convert_to_minute(as.character(input$Arrival_time))
arrival_minute
duration <- as.integer(input$Duration)
duration
input <- toy[8888,]
reference_start_time <- strftime("2014/1/1 0:0", "%Y-%m-%d %H:%M:%OS")  # set when elf starts working on toy
id = input$ToyId
arrival_minute <- convert_to_minute(as.character(input$Arrival_time))
duration <- as.integer(input$Duration)
completed_minute <- 0
duration
arrival_minute
id
outside_toy_start_period <- function(arrival_minute, start_minute){
# Checks that work on toy does not start outside of the allowed starting period.
# :param hrs: Hours class
# :param start_minute: minute the work is scheduled to start
# :return: True of outside of allowed starting period, False otherwise
return (start_minute < arrival_minute)
}
outside_toy_start_period(arrival_minute, reference_start_time)
outside_toy_start_period(arrival_minute, arrival_minute)
reference_start_time <- strftime("2015/1/1 0:0", "%Y-%m-%d %H:%M:%OS")  # set when elf starts working on toy
outside_toy_start_period(arrival_minute, reference_start_time)
arrival_minute
reference_start_time
outside_toy_start_period(arrival_minute, 0)
outside_toy_start_period(arrival_minute, 20000)
is_complete <- function(duration, completed_minute, start_minute, elf_duration, rating){
# Determines if the toy is completed given duration of work and elf's productivity rating
# param start_minute: minute work started
# param elf_duration: duration of work in minutes
# param rating: elf's productivity rating
# return: Boolean
if (duration/rating <= elf_duration){
completed_minute <- start_minute + as.integer(ceil(duration/rating))
return(completed_minute)
}else{
return(FALSE)
}
}
is_complete(duration, completed_minute, 20000, 20000, 1.0)
?ceil
round
?round
is_complete <- function(duration, completed_minute, start_minute, elf_duration, rating){
# Determines if the toy is completed given duration of work and elf's productivity rating
# param start_minute: minute work started
# param elf_duration: duration of work in minutes
# param rating: elf's productivity rating
# return: Boolean
if (duration/rating <= elf_duration){
completed_minute <- start_minute + as.integer(ceiling(duration/rating))
return(completed_minute)
}else{
return(FALSE)
}
}
is_complete(duration, completed_minute, 20000, 20000, 1.0)
is_complete(duration, completed_minute, 20000, 10000, 1.0)
as.integer(ceiling(duration/rating))
duration
is_complete(duration, completed_minute, 0, 10000, 1.0)
is_complete(duration, completed_minute, 0, 10, 1.0)
data.frame(reference_start_time=reference_start_time, id=id,
arrival_minute=arrival_minute, duration=duration, completed_minute=completed_minute)
toy_init <- function(input){
reference_start_time <- strftime("2015/1/1 0:0", "%Y-%m-%d %H:%M:%OS")  # set when elf starts working on toy
id = input$ToyId
arrival_minute <- convert_to_minute(as.character(input$Arrival_time))
duration <- as.integer(input$Duration)
completed_minute <- 0
return(data.frame(reference_start_time=reference_start_time, id=id,
arrival_minute=arrival_minute, duration=duration, completed_minute=completed_minute))
}
input <- toy[8888,]
toy_init(input)
input <- toy[88818,]
toy_init(input)
toy_task <- toy_init(input)
is_complete(toy_task$duration, toy_task$completed_minute, 0, 10, 1.0)
outside_toy_start_period(toy_task$arrival_minute, 20000)
is_complete(toy_task$duration, toy_task$completed_minute, 10000, 1000, 1.0)
outside_toy_start_period(toy_task$arrival_minute, 20000)
outside_toy_start_period(toy_task$arrival_minute, 10000)
input <- toy[8818,]
toy_task <- toy_init(input)
outside_toy_start_period(toy_task$arrival_minute, 10000)
is_complete(toy_task$duration, toy_task$completed_minute, 10000, 1000, 1.0)
input <- toy[888,]
toy_task <- toy_init(input)
outside_toy_start_period(toy_task$arrival_minute, 10000)
is_complete(toy_task$duration, toy_task$completed_minute, 10000, 1000, 1.0)
input <- toy[812388,]
toy_task <- toy_init(input)
is_complete(toy_task$duration, toy_task$completed_minute, 10000, 1000, 1.0)
init <- data.frame(
hours_per_day <- 10, # 10 hour day: 9 - 19
day_start <- 9 * 60,
day_end <- (9 + hours_per_day) * 60,
minutes_in_24h <- 24 * 60
)
init
## init ##
init <- data.frame(
hours_per_day = 10, # 10 hour day: 9 - 19
day_start = 9 * 60,
day_end = (9 + hours_per_day) * 60,
minutes_in_24h = 24 * 60
)
init
convert_to_minute <- function(arrival){
#     Converts the arrival time string to minutes since the reference start time,
#     Jan 1, 2014 at 00:00 (aka, midnight Dec 31, 2013)
#     :param arrival: string in format '2014 12 17 7 03' for Dec 17, 2014 at 7:03 am
#     :return: integer (minutes since arrival time)
time = strsplit(x = arrival, split = ' ')
time1 = paste(paste(time[[1]][1],time[[1]][2],time[[1]][3],sep = '/'),paste(time[[1]][4],time[[1]][5],sep = ":"),sep = " ")
time1 = strftime(time1, "%Y-%m-%d %H:%M:%OS")
time2 = strftime("2014/1/1 0:0", "%Y-%m-%d %H:%M:%OS")
age = as.integer(difftime(time1, time2, units = "mins"))
return(age)
}
input
convert_to_munute(input$Arrival_time)
convert_to_minute <- function(arrival){
#     Converts the arrival time string to minutes since the reference start time,
#     Jan 1, 2014 at 00:00 (aka, midnight Dec 31, 2013)
#     :param arrival: string in format '2014 12 17 7 03' for Dec 17, 2014 at 7:03 am
#     :return: integer (minutes since arrival time)
time = strsplit(x = arrival, split = ' ')
time1 = paste(paste(time[[1]][1],time[[1]][2],time[[1]][3],sep = '/'),paste(time[[1]][4],time[[1]][5],sep = ":"),sep = " ")
time1 = strftime(time1, "%Y-%m-%d %H:%M:%OS")
time2 = strftime("2014/1/1 0:0", "%Y-%m-%d %H:%M:%OS")
age = as.integer(difftime(time1, time2, units = "mins"))
return(age)
}
convert_to_minute(input$Arrival_time)
input$Arrival_time
convert_to_minute(as.character(input$Arrival_time))
input <- toy[888,]
toy_task <- toy_init(input)
convert_to_minute(as.character(input$Arrival_time))
hours_init
hours_init <- data.frame(
hours_per_day = 10, # 10 hour day: 9 - 19
day_start = 9 * 60,
day_end = (9 + hours_per_day) * 60,
minutes_in_24h = 24 * 60
)
hours_init
is_sanctioned_time <- function(hours_init, minute){
#     Return boolean True or False if a given time (in minutes) is a sanctioned working day minute.
return (((minute - hours_init$day_start) %% hours_init$minutes_in_24h) < (hours_init$hours_per_day * 60))
}
is_sanctioned_time(hours_init, 1)
is_sanctioned_time(hours_init, 9*60)
is_sanctioned_time(hours_init, 8*60)
is_sanctioned_time(hours_init, 9*60-1)
is_sanctioned_time(hours_init, 9*60)
is_sanctioned_time(hours_init, 17*60)
is_sanctioned_time(hours_init, 17*60+1)
is_sanctioned_time(hours_init, 19*60+1)
is_sanctioned_time(hours_init, 19*60)
is_sanctioned_time(hours_init, 19*60-1)
(hours_init$minutes_in_24h)
hours_init$hours_per_day * 60
get_sanctioned_breakdown <- function(hours_init, start_minute, duration){
#     Whole days (24-hr time periods) contribute fixed quantities of sanctioned and unsanctioned time. After
#     accounting for the whole days in the duration, the remainder minutes are tabulated as un/sanctioned.
#     :param start_minute:
#     :param duration:
#     :return:
full_days <- duration / (hours_init$minutes_in_24h)
sanctioned <- full_days * hours_init$hours_per_day * 60
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
for(minute in remainder_start:(start_minute+duration)){
if (is_sanctioned_time(minute)){
sanctioned <- sanctioned + 1
}else{
unsanctioned <- unsanctioned + 1
}
}
return (data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned))
}
get_sanctioned_breakdown(hours_init, 1000, 100)
get_sanctioned_breakdown <- function(hours_init, start_minute, duration){
#     Whole days (24-hr time periods) contribute fixed quantities of sanctioned and unsanctioned time. After
#     accounting for the whole days in the duration, the remainder minutes are tabulated as un/sanctioned.
#     :param start_minute:
#     :param duration:
#     :return:
full_days <- duration / (hours_init$minutes_in_24h)
sanctioned <- full_days * hours_init$hours_per_day * 60
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
for(minute in remainder_start:(start_minute+duration)){
if (is_sanctioned_time(hours_init, minute)){
sanctioned <- sanctioned + 1
}else{
unsanctioned <- unsanctioned + 1
}
}
return (data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned))
}
get_sanctioned_breakdown(hours_init, 1000, 100)
get_sanctioned_breakdown(hours_init, 10230, 100)
get_sanctioned_breakdown(hours_init, 11230, 100)
get_sanctioned_breakdown(hours_init, 130, 100)
get_sanctioned_breakdown(hours_init, 9*60, 100)
get_sanctioned_breakdown(hours_init, 9*60, 10)
start_minute <- 540
duration <- 10
full_days <- duration / (hours_init$minutes_in_24h)
full_days
sanctioned <- full_days * hours_init$hours_per_day * 60
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
sanctioned
unsanctioned
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
remainder_start
full_days
remainder_start:(start_minute+duration)
remainder_start
(start_minute+duration)
is_sanctioned_time(hours_init, minute)
is_sanctioned_time(hours_init, 550)
get_sanctioned_breakdown(hours_init, 9*60, 100)
get_sanctioned_breakdown(hours_init, 12*60, 100)
next_sanctioned_minute(hours_init, 100)
next_sanctioned_minute <- function(hours_init, minute){
#     Given a minute, finds the next sanctioned minute.
#     :param minute: integer representing a minute since reference time
#     :return: next sanctioned minute
if(is_sanctioned_time(hours_init, minute) and is_sanctioned_time(hours_init, (minute+1))){
return(minute+1)
}
num_days = minute / hours_init$minutes_in_24h
return(hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h)
}
next_sanctioned_minute <- function(hours_init, minute){
#     Given a minute, finds the next sanctioned minute.
#     :param minute: integer representing a minute since reference time
#     :return: next sanctioned minute
if(is_sanctioned_time(hours_init, minute) & is_sanctioned_time(hours_init, (minute+1))){
return(minute+1)
}
num_days = minute / hours_init$minutes_in_24h
return(hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h)
}
next_sanctioned_minute(hours_init, 100)
next_sanctioned_minute(hours_init, 200)
next_sanctioned_minute(hours_init, hours_init$day_start)
hours_init$day_start
next_sanctioned_minute(hours_init, hours_init$day_end)
3121-24*60
24*60
3121-24*60*2
next_sanctioned_minute <- function(hours_init, minute){
#     Given a minute, finds the next sanctioned minute.
#     :param minute: integer representing a minute since reference time
#     :return: next sanctioned minute
if(is_sanctioned_time(hours_init, minute) & is_sanctioned_time(hours_init, (minute+1))){
return(minute+1)
}
#     num_days = minute / hours_init$minutes_in_24h
#     return(hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h)
}
next_sanctioned_minute(hours_init, hours_init$day_end)
next_sanctioned_minute(hours_init, hours_init$day_start)
hours_init$minutes_in_24h
hours_init$day_end
hours_init$day_end/1440
num_days <- hours_init$day_end/1440
num_days
hours_init$day_start
hours_init$day_start + (num_days + 1)
(num_days + 1) * hours_init$minutes_in_24h
hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h
next_sanctioned_minute <- function(hours_init, minute){
#     Given a minute, finds the next sanctioned minute.
#     :param minute: integer representing a minute since reference time
#     :return: next sanctioned minute
if(is_sanctioned_time(hours_init, minute) & is_sanctioned_time(hours_init, (minute+1))){
return(minute + 1)
}
num_days <- minute / hours_init$minutes_in_24h
return(hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h)
}
next_sanctioned_minute <- function(hours_init, minute){
#     Given a minute, finds the next sanctioned minute.
#     :param minute: integer representing a minute since reference time
#     :return: next sanctioned minute
if(is_sanctioned_time(hours_init, minute) & is_sanctioned_time(hours_init, (minute+1))){
return(minute + 1)
}
num_days <- minute / hours_init$minutes_in_24h
return(hours_init$day_start + (num_days + 1) * hours_init$minutes_in_24h)
}
next_sanctioned_minute(hours_init, hours_init$day_end)
next_sanctioned_minute(hours_init, hours_init$day_start)
next_sanctioned_minute(hours_init, hours_init$day_start+12)
?range
range(1,10)
1:10
550:549
get_sanctioned_breakdown <- function(hours_init, start_minute, duration){
#     Whole days (24-hr time periods) contribute fixed quantities of sanctioned and unsanctioned time. After
#     accounting for the whole days in the duration, the remainder minutes are tabulated as un/sanctioned.
#     :param start_minute:
#     :param duration:
#     :return:
full_days <- duration / (hours_init$minutes_in_24h)
sanctioned <- full_days * hours_init$hours_per_day * 60
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
remainder_start <- start_minute + full_days * hours_init$minutes_in_24h
for(minute in remainder_start:(start_minute+duration-1)){
if (is_sanctioned_time(hours_init, minute)){
sanctioned <- sanctioned + 1
}else{
unsanctioned <- unsanctioned + 1
}
}
return (data.frame(sanctioned=sanctioned, unsanctioned=unsanctioned))
}
get_sanctioned_breakdown(hours_init, 12*60, 100)
remainder_start:(start_minute+duration-1)
full_days <- duration / (hours_init$minutes_in_24h)
full_days
full_days
sanctioned <- full_days * hours_init$hours_per_day * 60
sanctioned
unsanctioned <- full_days * (24 - hours_init$hours_per_day) * 60
unsanctioned
get_sanctioned_breakdown(hours_init, 12*60, 100)
get_sanctioned_breakdown(hours_init, 12*60, 1000)
1000 / (hours_init$minutes_in_24h)
1000 / (hours_init$minutes_in_24h) * hours_init$hours_per_day * 60
apply_resting_period <- function(hours_init, start, num_unsanctioned){
#     Enforces the rest period and returns the minute when the elf is next available for work.
#     Rest period is only applied to sanctioned work hours.
#     :param start: minute the REST period starts
#     :param num_unsanctioned: always > 0 number of unsanctioned minutes that need resting minutes
#     :return: next available minute after rest period has been applied
num_days_since_jan1 <- start / hours_init$minutes_in_24h
rest_time <- num_unsanctioned
rest_time_in_working_days <- rest_time / (60 * hours_init$hours_per_day)
rest_time_remaining_minutes <- rest_time %% (60 * hours_init$hours_per_day)
#     rest time is only applied to sanctioned work hours. If local_start is at an unsanctioned time,
#     need to set it to be the next start of day
local_start <- start %% hours_init$minutes_in_24h  # minute of the day (relative to a current day) the work starts
if(local_start < hours_init$day_start){
local_start <- hours_init$day_start
}else if(local_start > hours_init$day_end){
num_days_since_jan1 <- num_days_since_jan1 + 1
}
local_start <- hours_init$day_start
if((local_start + rest_time_remaining_minutes) > hours_init$day_end){
rest_time_in_working_days <- rest_time_in_working_days + 1
}
rest_time_remaining_minutes <- rest_time_remaining_minutes - (hours_init$day_end - local_start)
local_start <- hours_init$day_start
total_days <- num_days_since_jan1 + rest_time_in_working_days
return (total_days * hours_init$minutes_in_24h + local_start + rest_time_remaining_minutes)
}
next_sanctioned_minute(hours_init, hours_init$day_start+12)
get_sanctioned_breakdown(hours_init, 12*60, 1000)
####################################
apply_resting_period(hours_init, 12*60, 585.3333)
12*60
elf <- data.frame(elfid = 1:900)
elf
elf_init <- function(input){
id <- input$elfid
rating <- 1.0
next_available_time <- 540  # Santa's Workshop opens Jan 1, 2014 9:00 (= 540 minutes)
rating_increase <- 1.02
rating_decrease <- 0.90
return(data.frame(id=id, rating=rating, next_available_time=next_available_time,
rating_increase=rating_increase, rating_decrease=rating_decrease))
}
elf_init(elf[1,])
elf_init(elf[1])
elf_init(elf)
elf_init(elf[1,1])
elf_init(elf[,1])
elf_init(elf)
elf_init
elf_init <- function(input){
#     Each Elf starts with a rating of 1.0 and are available at 09:00 on Jan 1.
id <- input$elfid
rating <- 1.0
next_available_time <- 540  # Santa's Workshop opens Jan 1, 2014 9:00 (= 540 minutes)
rating_increase <- 1.02
rating_decrease <- 0.90
return(data.frame(id=id, rating=rating, next_available_time=next_available_time,
rating_increase=rating_increase, rating_decrease=rating_decrease))
}
elf_init(elf)
elf_list <- elf_init(elf)
update_elf <- function(elf_list, hrs, toy, start_minute, duration){
#     Updates the elf's productivity rating and next available time based on last toy completed.
#     :param hrs: Hours object for bookkeeping
#     :param toy: Toy object for the toy the elf just finished
#     :param start_minute: minute work started
#     :param duration: duration of work, in minutes
#     :return: void
elf_list$update_next_available_minute(hrs, start_minute, duration)
elf_list$update_productivity(hrs, start_minute, int(math.ceil(toy.duration / self.rating)))
}
?round
floor(1.23123)
ceiling(1.213123)
update_elf <- function(elf_list, hrs, toy, start_minute, duration){
#     Updates the elf's productivity rating and next available time based on last toy completed.
#     :param hrs: Hours object for bookkeeping
#     :param toy: Toy object for the toy the elf just finished
#     :param start_minute: minute work started
#     :param duration: duration of work, in minutes
#     :return: void
update_next_available_minute(elf_list, hrs, start_minute, duration)
update_productivity(hrs, start_minute, int(elf_list, ceiling(toy$duration / elf_list$rating)))
}
